#!/usr/bin/env python3.8


import argparse
import os
import shutil
import subprocess
import sys
import tempfile
import traceback
from typing import List
import zipfile
import yaml


# If any file in these folders are changed, rebuild all services
REBUILD_FOLDERS = [
    "shared"
]

# If any file in these service folders are changed, ignore it.
# If the folder does not have a `metadata.yaml` file, the folder is ignored
# anyway.
IGNORE_FOLDERS = []


def get_args():
    """
    Parse command line arguments
    """

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    parser_changed = subparsers.add_parser("changed")
    parser_changed.add_argument("commit_id")
    parser_changed.set_defaults(command="changed")

    parser_services = subparsers.add_parser("services")
    parser_services.add_argument("--env-only", default=False, action="store_true")
    parser_services.set_defaults(command="services")

    parser_upload = subparsers.add_parser("upload")
    parser_upload.add_argument("service")
    parser_upload.set_defaults(command="upload")

    return parser.parse_args()


def get_metadata(service_name: str) -> List[str]:
    """
    Get metadata for a service
    """

    metafile = os.path.join(os.getcwd(), service_name, "metadata.yaml")
    if not os.path.isfile(metafile):
        raise ValueError("Metadata file not found for {}".format(service_name))

    with open(metafile) as fp:
        metadata = yaml.load(fp, Loader=yaml.SafeLoader)

    return metadata


def get_services(env_only: bool=False) -> List[str]:
    """
    Gather the list of services
    """

    # Gather all services
    services = {
        # Mapping name: reverse dependencies
        name: {"deps": [], "rdeps": [], "metadata": get_metadata(name)}
        for name in os.listdir(os.getcwd())
        if os.path.isfile(os.path.join(os.getcwd(), name, "metadata.yaml"))
        and name not in IGNORE_FOLDERS
    }

    if env_only:
        for name in list(services.keys()):
            if not services[name]["metadata"].get("flags", {}).get("environment", True):
                del services[name]

    to_scan = []

    # Parse dependencies
    for name in services.keys():
        if len(services[name]["metadata"].get("dependencies", [])) == 0:
            to_scan.append(name)
        for dep in services[name]["metadata"].get("dependencies", []):
            if name == dep:
                continue
            # This service depends on all the services
            elif dep == "*":
                for dname in services.keys():
                    # Only inject if this is not the same service
                    if dname != name:
                        services[name]["deps"].append(dname)
                        services[dname]["rdeps"].append(name)
            elif dep not in services:
                raise ValueError("Dependency {} of {} not found".format(dep, name))
            else:
                services[name]["deps"].append(dep)
                # Inject as a reverse dependency
                services[dep]["rdeps"].append(name)

    # Scan all services until there are not more services to scan. This looks
    # for services with no dependencies that were unprocessed.
    # The initial `to_scan` list is seeded by all services without any
    # dependency. Whenever this scans a dependency, it goes through the list of
    # reverse dependencies (services depending on this one) and remove itself
    # from the list of dependencies of that service. Whenever the list of
    # dependencies for a service is empty, this means that all dependencies are
    # satisfied by values in the `retval` list.
    # At the end, all services should be resolved. If it's not possible to
    # remove all dependencies of a service, this means that there is a circular
    # dependency.
    retval = []
    while len(to_scan) > 0:
        name = to_scan.pop(0)
        # If the service is already processed, something has gone wrong.
        if name in retval:
            raise ValueError("Service {} already present in services: {}".format(name, retval))
        retval.append(name)
        for rname in services[name]["rdeps"]:
            services[rname]["deps"].remove(name)
            if len(services[rname]["deps"]) == 0:
                to_scan.append(rname)

    # If there is a discrepancy, this means that there is a circular
    # dependency.
    if len(retval) != len(services):
        for key, value in services.items():
            print(key, value)
        raise ValueError("Potential circular dependency found: mismatch between number of services: {} vs {}".format(len(retval), len(services)))

    return retval


def get_changed(commit_id: str="0") -> List[str]:
    """
    Gather the services that have changed
    """

    services = get_services()

    # '0' is a special value, usually for first runs, that trigger a complete
    # (re)build.
    if commit_id == "0":
        return services

    process = subprocess.run(["git", "diff", commit_id, "--name-only"], capture_output=True, text=True)
    process.check_returncode()

    changed = []
    for filename in process.stdout.split("\n"):
        basename = filename.split("/", 1)[0]

        # If one file from the special folders has changed, all services need
        # to be rebuilt.
        if basename in REBUILD_FOLDERS:
            return services

        if basename in services:
            changed.append(basename)

    # Only return each service once
    return list(set(changed))


def upload_template(service: str):
    """
    Upload templates to S3
    """

    # Import here to prevent issues during first execution
    import boto3

    template_file = os.path.join(service, "build", "template.out")
    if not os.path.isfile(template_file):
        raise ValueError("File '{}' does not exist".format(template_file))

    artifacts_dir = os.path.join(service, "build", "artifacts")
    artifact_files = os.listdir(artifacts_dir)

    # Create zip archive
    tmpdir = tempfile.mkdtemp()
    try:
        archive = os.path.join(tmpdir, "{}.zip".format(service))

        with zipfile.ZipFile(archive, mode="w") as zip:
            zip.write(template_file, arcname="template.yaml")
            for artifact_file in artifact_files:
                zip.write(
                    os.path.join(artifacts_dir, artifact_file),
                    arcname=artifact_file
                )

        s3 = boto3.resource("s3")
        bucket = s3.Bucket(os.environ.get("S3_BUCKET", "{}-src".format(os.environ.get("USER", ""))))

        bucket.upload_file(archive, "templates/{}.zip".format(service))
    finally:
        shutil.rmtree(tmpdir)


if __name__ == "__main__":
    args = get_args()

    try:
        if args.command == "changed":
            for service in get_changed(args.commit_id):
                print(service)

        if args.command == "services":
            for service in get_services(args.env_only):
                print(service)

        if args.command == "upload":
            upload_template(args.service)
    except Exception as exc:
        traceback.print_exc()
        sys.exit(1)