#!/usr/bin/env python3


import argparse
import copy
import os
import shutil
import subprocess
import sys
from typing import List


def get_args() -> argparse.Namespace:
    """
    Return arguments from the command line
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("service")
    parser.add_argument("commands", nargs="+")
    parser.add_argument("--color", default="auto", choices=["yes", "no", "auto"])
    parser.add_argument("--env", "-e", default="dev")
    parser.add_argument("--quiet", "-q", default=False, type=lambda x: x == "yes")

    return parser.parse_args()


class ToolBox:
    def __init__(self, service: str, kwargs: str={}):
        self.service = service
        self.color = kwargs.get("color", "auto")
        self.env = kwargs.get("env", "dev")
        self.quiet = kwargs.get("quiet", False)

    @property
    def is_interactive(self):
        return os.isatty(sys.stdout.fileno())

    @property
    def build_dir(self):
        return os.path.join(self.service, "build")

    @property
    def resources_dir(self):
        return os.path.join(self.service, "resources")

    @property
    def resources_build_dir(self):
        return os.path.join(self.service, "build", "resources")

    @property
    def service_dir(self):
        return self.service

    @property
    def shared_dir(self):
        return "shared"

    @property
    def source_dir(self):
        return os.path.join(self.service, "src")

    @property
    def source_build_dir(self):
        return os.path.join(self.service, "build", "src")

    @property
    def tests_dir(self):
        return os.path.join(self.service, "tests")

    def run(self, commands: List[str]):
        """
        Run a sequence of commands
        """

        if not os.path.isdir(self.service_dir) or self.service in ["docs", "shared", "tools"]:
            raise ValueError("Service '{}' does not exist".format(self.service))

        cmds = []

        for command in commands:
            cmd = getattr(self, "cmd_{}".format(command.replace("-", "_")), None)
            if cmd is None:
                raise ValueError("Command '{}' does not exist".format(command))
            cmds.append(cmd)

        try:
            for cmd in cmds:
                cmd()
        except Exception as exc:
            print(self.text_red("{}: {}".format(exc.__class__.__name__, str(exc))))
            raise exc

    def cmd_build(self):
        """
        'build' command

        This command performs the following operations:
        
        * Copy files to the 'build' folder
        * Merge OpenAPI document for API Gateway
        * Install packages for Lambda functions
        """

        self.info("Building {} artifacts".format(self.service))

        # Copy files to build directory
        os.mkdir(self.build_dir)

        # Copy folders
        # No need to copy tests folder
        for name in ["src", "resources"]:
            if not os.path.isdir(os.path.join(self.service_dir, name)):
                continue
            shutil.copytree(os.path.join(self.service_dir, name), os.path.join(self.build_dir, name))

        # Copy files
        for name in ["template.yaml"]:
            if not os.path.isfile(os.path.join(self.service_dir, name)):
                continue
            shutil.copy2(os.path.join(self.service_dir, name), os.path.join(self.build_dir, name))

        # Parse OpenAPI specifications and copy in the build folder, if any
        self._copy_openapi()

        # Install Python3 packages
        self._install_packages()

    def cmd_clean(self):
        """
        'clean' command

        Removes the 'build' folder for the service.
        """

        self.info("Cleaning {} build folder".format(self.service))

        try:
            shutil.rmtree(self.build_dir)
        # Ignore if the folder doesn't exist
        except FileNotFoundError:
            pass

    def cmd_deploy(self):
        """
        'deploy' command

        Deploys the service to the developer's AWS account. By default, this
        assumes that this is a development stack.
        """

        self.info("Deploying {} in {}".format(self.service, self.env))

        template_file = os.path.join(self.build_dir, "template.out")
        stack_name = "ecommerce-{}-{}".format(self.env, self.service)

        if not os.path.isdir(self.build_dir) or not os.path.isfile(template_file):
            raise ValueError("'{}' or '{}' not found.".format(self.build_dir, template_file))

        # Display warning for prod environment
        if self.env == "prod":
            self.warning("Prod deployment for {}".format(self.service))

        # Load parameter overrides
        base_params = {
            "Environment": self.env
        }
        metadata = self._get_metadata()
        parameters = copy.deepcopy(base_params)
        for key, value in metadata.get("parameters", {}).items():
            parameters[key] = value.format(**base_params)

        # Deploy stack
        self.run_process(["aws", "cloudformation", "deploy",
            "--stack-name", stack_name,
            "--capabilities", "CAPABILITY_IAM",
            "--parameter-overrides"] + ["{}={}".format(k, v) for k, v in parameters.items()] +
            ["--template-file", template_file])

    def cmd_lint(self):
        """
        'lint' command

        Lint various resources in the service. This currently supports:
        
        - CloudFormation templates
        - Lambda function code
        - OpenAPI document
        """

        self.info("Linting {} code".format(self.service))

        # Lint CloudFormation template
        template_file = os.path.join(self.service, "template.yaml")
        if os.path.isfile(template_file):
            self.run_process([
                "cfn-lint", template_file,
                "--append-rules", os.path.join(self.shared_dir, "lint", "rules")
            ])

        # Lint Lambda function code
        if not os.path.isdir(self.source_dir):
            return

        files = []
        for function_name in os.listdir(self.source_dir):
            function_dir = os.path.join(self.source_dir, function_name)
            if not os.path.isdir(function_dir):
                continue

            for filename in os.listdir(function_dir):
                if filename.lower().find(".py") == len(filename)-3:
                    files.append(os.path.join(function_dir, filename))

        process = self.run_process([
            "pylint",
            "--rcfile", os.path.join(self.shared_dir, "lint", "pylintrc")
        ] + files, check=False)
        # Only raise an error for fatal and error messages
        # https://docs.pylint.org/en/1.6.0/run.html#exit-codes
        if process.returncode in [1, 2, 32]:
            process.check_returncode()

        # Lint OpenAPI specifications
        openapi_file = os.path.join(self.resources_dir, "openapi.yaml")
        if os.path.isfile(openapi_file):
            self.run_process([
                "speccy",
                "--config", os.path.join(self.shared_dir, "lint", "speccy.yaml"),
                "lint", openapi_file
            ])

    def cmd_metadata(self):
        """
        'metadata' command

        Display metadata about the service
        """

        self.info("Gathering {} metadata".format(self.service))

        metadata = self._get_metadata()

        print("{}: {}".format(self.text_blue("Service name"), metadata["name"]))
        if metadata.get("permissions", []):
            print("{}:".format(self.text_blue("Permissions")))
            for permission in metadata["permissions"]:
                print(" - {}: {}".format(self.text_blue("Service"), permission["service"]))
                for key, value in permission.get("api", {}).items():
                    print("   {}: {}".format(self.text_blue(key), ",".join(value)))
                if permission.get("events", []):
                    print("   {}: {}".format(self.text_blue("events"), ",".join(permission["events"])))

        if metadata.get("dependencies", []):
            print("{}:".format(self.text_blue("Dependencies")))
            for dependency in metadata["dependencies"]:
                print(" - {}".format(dependency))

        if metadata.get("parameters", {}):
            print("{}:".format(self.text_blue("Parameters")))
            for key, value in metadata["parameters"].items():
                print(" - {}: {}".format(self.text_blue(key), value))

    def cmd_package(self):
        """
        'package' command

        Package the CloudFormation template and stores artifacts into an S3
        bucket provided by the 'S3_BUCKET' environment variable.
        """

        self.info("Packaging {} artifacts".format(self.service))

        s3_bucket = os.environ.get("S3_BUCKET", "{}-src".format(os.environ["USER"]))

        workdir = os.getcwd()
        os.chdir(self.build_dir)
        process = self.run_process(["aws", "cloudformation", "package", "--s3-bucket", s3_bucket,
            "--template-file", "template.yaml",
            "--output-template-file", "template.out"], check=False)

        os.chdir(workdir)
        # Make sure that we return to the work directory before triggering a failure
        process.check_returncode()

    def cmd_tests_unit(self):
        """
        'tests-unit' command

        Run unit tests for Lambda functions defined in the service.
        """

        self.info("Running {} unit tests".format(self.service))

        tests_dir = os.path.join(self.tests_dir, "unit")

        # If there are no tests, abort
        if not os.path.isdir(tests_dir):
            raise ValueError("'{}' does not exist".format(tests_dir))

        # Set environment variables
        os.environ["ECOM_BUILD_DIR"] = self.build_dir

        # Inject shared modules for unit tests in the PYTHONPATH
        shared_tests = os.path.join(self.shared_dir, "tests", "unit")
        if os.environ.get("PYTHONPATH", "") != "":
            os.environ["PYTHONPATH"] = "{}:{}".format(shared_tests, os.environ["PYTHONPATH"])
        else:
            os.environ["PYTHONPATH"] = shared_tests

        # Inject environment variables for boto3
        os.environ["AWS_ACCESS_KEY_ID"] = ""
        os.environ["AWS_SECRET_ACCESS_KEY"] = ""
        os.environ["AWS_DEFAULT_REGION"] = "eu-west-1"

        self.run_process(["pytest", tests_dir,
            "--cov", self.build_dir,
            "--cov-config", os.path.join(shared_tests, "coveragerc")])

    def cmd_tests_integ(self):
        """
        'tests-integ' command

        Run integration tests for a service.
        """

        self.info("Running {} integration tests".format(self.service))

        tests_dir = os.path.join(self.tests_dir, "integ")
        if not os.path.isdir(tests_dir):
            raise ValueError("'{}' does not exist".format(tests_dir))

        if self.env == "prod":
            raise ValueError("Cannot run integration tests in prod")

        # Inject shared modules for unit tests in the PYTHONPATH
        shared_tests = os.path.join(self.shared_dir, "tests", "integ")
        if os.environ.get("PYTHONPATH", "") != "":
            os.environ["PYTHONPATH"] = "{}:{}".format(shared_tests, os.environ["PYTHONPATH"])
        else:
            os.environ["PYTHONPATH"] = shared_tests

        # Set the environment name
        os.environ["ECOM_ENVIRONMENT"] = self.env

        self.run_process(["pytest", tests_dir])

    def text_red(self, text: str) -> str:
        """
        Return the text in red if this is an interactive session
        """
        if self.color == "yes" or (self.is_interactive and self.color == "auto"):
            return "\033[91m{}\033[0m".format(text)
        return text

    def text_green(self, text: str) -> str:
        """
        Return the text in green if this is an interactive session
        """
        if self.color == "yes" or (self.is_interactive and self.color == "auto"):
            return "\033[92m{}\033[0m".format(text)
        return text

    def text_yellow(self, text: str) -> str:
        """
        Return the text in green if this is an interactive session
        """
        if self.color == "yes" or (self.is_interactive and self.color == "auto"):
            return "\033[93m{}\033[0m".format(text)
        return text

    def text_blue(self, text: str) -> str:
        """
        Return the text in blue if this is an interactive session
        """
        if self.color == "yes" or (self.is_interactive and self.color == "auto"):
            return "\033[94m{}\033[0m".format(text)
        return text

    def info(self, text: str) -> None:
        """
        Print an information message
        """

        print("[*] {}".format(self.text_blue(text)))

    def warning(self, text: str) -> None:
        """
        Print a warning message
        """

        print("[!] {}".format(self.text_yellow(text)))

    def error(self, text: str) -> None:
        """
        Print an error message
        """

        print("[!] {}".format(self.text_red(text)))

    def run_process(self, cmds: List[str], check: bool=True):
        """
        Run a subprocess
        """

        if self.quiet:
            process = subprocess.run(cmds, capture_output=True, text=True, stderr=subprocess.STDOUT)
        else:
            process = subprocess.run(cmds)

        if check:
            try:
                process.check_returncode()
            except Exception as exc:
                if self.quiet:
                    print(process.stdout)
                raise exc
        return process

    def _copy_openapi(self):
        """
        Parse OpenAPI specs and returns a merged document
        """

        openapi_file = os.path.join(self.resources_dir, "openapi.yaml")
        openapi_out_file = os.path.join(self.resources_build_dir, "openapi.yaml")

        # Skip if there are no OpenAPI specifications for that service
        if not os.path.isfile(openapi_file):
            return

        self.run_process(["speccy", "resolve", openapi_file, "-o", openapi_out_file])

    def _get_metadata(self):
        """
        Load metadata for the service
        """

        import jsonschema
        import yaml

        schema_file = os.path.join(self.shared_dir, "metadata", "schema.yaml")
        metadata_file = os.path.join(self.service, "metadata.yaml")

        if not os.path.isfile(metadata_file):
            raise ValueError("Missing metadata file '{}'".format(metadata_file))

        with open(schema_file) as fp:
            schema = yaml.load(fp, Loader=yaml.SafeLoader)

        with open(metadata_file) as fp:
            metadata = yaml.load(fp, Loader=yaml.SafeLoader)

        jsonschema.validate(metadata, schema)

        return metadata

    def _install_packages(self):
        """
        Install packages for Lambda functions in the service
        """
        if not os.path.isdir(self.source_build_dir):
            return

        # Loop through directories in the 'src' folder
        for name in os.listdir(self.source_build_dir):
            path = os.path.join(self.source_build_dir, name)

            # If there is a requirements.txt file, we need to install extra packages.
            if os.path.isfile(os.path.join(path, "requirements.txt")):
                self.run_process(["/usr/bin/env", "python3", "-m", "pip", "install",
                    "--requirement", os.path.join(path, "requirements.txt"),
                    "--target", path])

if __name__ == "__main__":
    args = get_args()

    toolbox = ToolBox(args.service, vars(args))
    toolbox.run(args.commands)