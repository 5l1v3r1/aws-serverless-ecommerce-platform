#!/usr/bin/env python3

import argparse
import os
import shutil
import subprocess
from typing import List
import boto3


def get_args() -> argparse.Namespace:
    """
    Return arguments from the command line
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("service")
    parser.add_argument("commands", nargs="+")

    return parser.parse_args()


class ToolBox:
    def __init__(self, service: str):
        self.service = service

    @property
    def build_dir(self):
        return os.path.join(self.service, "build")

    @property
    def resources_dir(self):
        return os.path.join(self.service, "resources")

    @property
    def resources_build_dir(self):
        return os.path.join(self.service, "build", "resources")

    @property
    def service_dir(self):
        return self.service

    @property
    def shared_dir(self):
        return "shared"

    @property
    def source_dir(self):
        return os.path.join(self.service, "src")

    @property
    def source_build_dir(self):
        return os.path.join(self.service, "build", "src")

    @property
    def tests_dir(self):
        return os.path.join(self.service, "tests")

    def run(self, commands: List[str]):
        """
        Run a sequence of commands
        """

        if not os.path.isdir(self.service_dir) or self.service in ["docs", "shared", "tools"]:
            raise ValueError("Service '{}' does not exist".format(self.service))

        cmds = []

        for command in commands:
            cmd = getattr(self, "cmd_{}".format(command.replace("-", "_")), None)
            if cmd is None:
                raise ValueError("Command '{}' does not exist".format(command))
            cmds.append(cmd)

        for cmd in cmds:
            cmd()

    def cmd_build(self):
        """
        'build' command

        This command performs the following operations:
        
        * Copy files to the 'build' folder
        * Merge OpenAPI document for API Gateway
        * Install packages for Lambda functions
        """

        # Copy files to build directory
        os.mkdir(self.build_dir)

        # Copy folders
        # No need to copy tests folder
        for name in ["src", "resources"]:
            if not os.path.isdir(os.path.join(self.service_dir, name)):
                continue
            shutil.copytree(os.path.join(self.service_dir, name), os.path.join(self.build_dir, name))

        # Copy files
        for name in ["template.yaml"]:
            if not os.path.isfile(os.path.join(self.service_dir, name)):
                continue
            shutil.copy2(os.path.join(self.service_dir, name), os.path.join(self.build_dir, name))

        # Parse OpenAPI specifications and copy in the build folder, if any
        self._copy_openapi()

        # Install Python3 packages
        self._install_packages()

    def cmd_clean(self):
        """
        'clean' command

        Removes the 'build' folder for the service.
        """

        shutil.rmtree(self.build_dir)

    def cmd_deploy(self):
        """
        'deploy' command

        Deploys the service to the developer's AWS account. This assumes that
        this is a development stack.
        """

        template_file = os.path.join(self.build_dir, "template.out")

        stack_name = "ecommerce-{}".format(self.service)

        if not os.path.isdir(self.build_dir) or not os.path.isfile(template_file):
            raise ValueError("'{}' or '{}' not found.".format(self.build_dir, template_file))

        process = subprocess.run(["aws", "cloudformation", "deploy",
            "--stack-name", stack_name,
            "--capabilities", "CAPABILITY_IAM",
            "--template-file", template_file])
        process.check_returncode()

    def cmd_lint(self):
        """
        'lint' command

        Lint various resources in the service. This currently supports:
        
        - CloudFormation templates
        - Lambda function code
        """

        # Lint CloudFormation template
        template_file = os.path.join(self.service, "template.yaml")
        if os.path.isfile(template_file):
            process = subprocess.run(["cfn-lint", template_file])
            process.check_returncode()

        # Lint Lambda function code
        if not os.path.isdir(self.source_dir):
            return

        files = []
        for function_name in os.listdir(self.source_dir):
            function_dir = os.path.join(self.source_dir, function_name)
            if not os.path.isdir(function_dir):
                continue

            for filename in os.listdir(function_dir):
                if filename.lower().find(".py") == len(filename)-3:
                    files.append(os.path.join(function_dir, filename))

        process = subprocess.run([
            "pylint",
            "--rcfile", os.path.join(self.shared_dir, "lint", "pylintrc")
        ] + files)
        process.check_returncode()

        # Lint OpenAPI specifications
        openapi_file = os.path.join(self.resources_dir, "openapi.yaml")
        if os.path.isfile(openapi_file):
            process = subprocess.run([
                "speccy",
                "--config", os.path.join(self.shared_dir, "lint", "speccy.yaml"),
                "lint", openapi_file
            ])
            process.check_returncode()


    def cmd_package(self):
        """
        'package' command

        Package the CloudFormation template and stores artifacts into an S3
        bucket provided by the 'S3_BUCKET' environment variable.
        """

        s3_bucket = os.environ.get("S3_BUCKET", "{}-src".format(os.environ["USER"]))

        workdir = os.getcwd()
        os.chdir(self.build_dir)
        process = subprocess.run(["aws", "cloudformation", "package", "--s3-bucket", s3_bucket,
            "--template-file", "template.yaml",
            "--output-template-file", "template.out"])

        os.chdir(workdir)
        # Make sure that we return to the work directory before triggering a failure
        process.check_returncode()


    def cmd_tests_unit(self):
        """
        'tests-unit' command

        Run unit tests for Lambda functions defined in the service.
        """

        tests_dir = os.path.join(self.tests_dir, "unit")

        # If there are no tests, abort
        if not os.path.isdir(tests_dir):
            raise ValueError("'{}' does not exist".format(tests_dir))

        # Set environment variables
        os.environ["BUILD_DIR"] = self.build_dir

        # Inject shared modules for unit tests in the PYTHONPATH
        shared_tests = os.path.join(self.shared_dir, "tests", "unit")
        if os.environ.get("PYTHONPATH", "") != "":
            os.environ["PYTHONPATH"] = "{}:{}".format(shared_tests, os.environ["PYTHONPATH"])
        else:
            os.environ["PYTHONPATH"] = shared_tests

        process = subprocess.run(["pytest", tests_dir,
            "--cov", self.build_dir,
            "--cov-config", os.path.join(shared_tests, "coveragerc")])
        process.check_returncode()

    def cmd_tests_integ(self):
        """
        'tests-integ' command

        Run integration tests for a service.
        """

        ssm = boto3.client("ssm")

        tests_dir = os.path.join(self.tests_dir, "integ")
        if not os.path.isdir(tests_dir):
            raise ValueError("'{}' does not exist".format(tests_dir))

        try:
            env = ssm.get_parameter(Name="/ecommerce/{}/environment".format(self.service))
        except:
            raise ValueError("SSM parameter '/ecommerce/{}/environment' not found".format(self.service))

        if env["Parameter"]["Value"].lower() == "prod":
            raise ValueError("Prod environment detected")

        # Inject shared modules for unit tests in the PYTHONPATH
        shared_tests = os.path.join(self.shared_dir, "tests", "integ")
        if os.environ.get("PYTHONPATH", "") != "":
            os.environ["PYTHONPATH"] = "{}:{}".format(shared_tests, os.environ["PYTHONPATH"])
        else:
            os.environ["PYTHONPATH"] = shared_tests

        process = subprocess.run(["pytest", tests_dir])
        process.check_returncode()

    def _copy_openapi(self):
        """
        Parse OpenAPI specs and returns a merged document
        """

        openapi_file = os.path.join(self.resources_dir, "openapi.yaml")
        openapi_out_file = os.path.join(self.resources_build_dir, "openapi.yaml")

        # Skip if there are no OpenAPI specifications for that service
        if not os.path.isfile(openapi_file):
            return

        process = subprocess.run(["speccy", "resolve", openapi_file, "-o", openapi_out_file])
        process.check_returncode()

    def _install_packages(self):
        """
        Install packages for Lambda functions in the service
        """
        if not os.path.isdir(self.source_build_dir):
            return

        # Loop through directories in the 'src' folder
        for name in os.listdir(self.source_build_dir):
            path = os.path.join(self.source_build_dir, name)

            # If there is a requirements.txt file, we need to install extra packages.
            if os.path.isfile(os.path.join(path, "requirements.txt")):
                process = subprocess.run(["/usr/bin/env", "python3", "-m", "pip", "install",
                    "--requirement", os.path.join(path, "requirements.txt"),
                    "--target", path])
                process.check_returncode()

if __name__ == "__main__":
    args = get_args()

    toolbox = ToolBox(args.service)
    try:
        toolbox.run(args.commands)
    except Exception as exc:
        print("Exception caught: {}".format(exc))