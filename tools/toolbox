#!/usr/bin/env python3


import argparse
import copy
import json
import os
import shutil
import subprocess
import sys
import traceback
from typing import List
import boto3
import jsonschema
import yaml


def get_args() -> argparse.Namespace:
    """
    Return arguments from the command line
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("service")
    parser.add_argument("commands", nargs="+")
    parser.add_argument("--color", default="auto", choices=["yes", "no", "auto"])
    parser.add_argument("--environment", "--env", "-e", default="dev")
    parser.add_argument("--quiet", "-q", default=False, type=lambda x: x == "yes")

    return parser.parse_args()


class ToolBox:
    """
    CLI interface
    """

    def __init__(self, service: str, kwargs: str={}):
        self.service = service
        self.color = kwargs.get("color", "auto")
        self.quiet = kwargs.get("quiet", False)

        self.metadata = self._get_metadata()
        self._orig_environment = kwargs.get("environment", "dev")
        self.environment = self._get_environment(kwargs.get("environment", "dev"))

    ##############
    # PROPERTIES #
    ##############

    @property
    def is_interactive(self):
        return os.isatty(sys.stdout.fileno())

    @property
    def build_dir(self):
        return os.path.join(self.service, "build")

    @property
    def artifacts_build_dir(self):
        return os.path.join(self.service, "build", "artifacts")

    @property
    def resources_dir(self):
        return os.path.join(self.service, "resources")

    @property
    def resources_build_dir(self):
        return os.path.join(self.service, "build", "resources")

    @property
    def service_dir(self):
        return self.service

    @property
    def shared_dir(self):
        return "shared"

    @property
    def source_dir(self):
        return os.path.join(self.service, "src")

    @property
    def source_build_dir(self):
        return os.path.join(self.service, "build", "src")

    @property
    def tests_dir(self):
        return os.path.join(self.service, "tests")

    ##############
    # RUN METHOD #
    ##############

    def run(self, commands: List[str]):
        """
        Run a sequence of commands
        """

        if not os.path.isdir(self.service_dir) or self.service in ["docs", "shared", "tools"]:
            raise ValueError("Service '{}' does not exist".format(self.service))

        cmds = []

        for command in commands:
            cmd = getattr(self, "cmd_{}".format(command.replace("-", "_")), None)
            if cmd is None:
                raise ValueError("Command '{}' does not exist".format(command))
            cmds.append(cmd)

        try:
            for cmd in cmds:
                cmd()
        except Exception as exc:
            print(self.text_red("{}: {}".format(exc.__class__.__name__, str(exc))))
            traceback.print_exc()
            sys.exit(1)

    #################
    # META-COMMANDS #
    #################

    def cmd_ci(self):
        """
        'ci' command

        This is a convenience command that runs the following commands:

        - display
        - lint
        - clean
        - build
        - tests-unit
        """

        self.run(["display", "lint", "clean", "build", "tests-unit"])

    def cmd_display(self):
        """
        'display' command

        This is a convenience command that runs the following commands:

        - display-metadata
        - display-parameters
        - display-tags
        """

        self.run(["display-metadata", "display-parameters", "display-tags"])

    def cmd_all(self):
        """
        'all' command

        This is a convenience command that runs the following commands:

        - display
        - lint
        - clean
        - build
        - tests-unit
        - check-deps
        - package
        - deploy
        - tests-integ
        """

        self.run([
            "display", "lint", "clean", "build", "tests-unit",
            "check-deps", "package", "deploy", "tests-integ"
        ])

    ############
    # COMMANDS #
    ############

    def cmd_build(self):
        """
        'build' command

        This command performs the following operations:
        
        * Copy files to the 'build' folder
        * Merge OpenAPI document for API Gateway
        * Install packages for Lambda functions
        """

        self.info("Building {} artifacts".format(self.service))

        # Copy files to build directory
        os.mkdir(self.build_dir)

        # Copy folders
        # No need to copy tests folder
        for name in ["src", "resources"]:
            if not os.path.isdir(os.path.join(self.service_dir, name)):
                continue
            shutil.copytree(os.path.join(self.service_dir, name), os.path.join(self.build_dir, name))

        # Copy files
        for name in ["template.yaml"]:
            if not os.path.isfile(os.path.join(self.service_dir, name)):
                continue
            shutil.copy2(os.path.join(self.service_dir, name), os.path.join(self.build_dir, name))

        # Parse OpenAPI specifications and copy in the build folder, if any
        self._copy_openapi()

        # Install Python3 packages
        self._install_packages()

        # Create artifacts
        self._build_artifacts()

    def cmd_check_deps(self):
        """
        'check-deps' command

        Check if dependencies are properly deployed.
        """

        self.info("Checking dependencies for {}".format(self.service))

        cloudformation = boto3.client("cloudformation")
        dependencies = self.metadata.get("dependencies", [])
        # If it contains '*', it means that this service has all other services
        # as dependency.
        if "*" in dependencies:
            dependencies = self._get_all_services()
        missing_deps = []

        for dependency in dependencies:
            # Check for environment-aware stacks
            try:
                retval = cloudformation.describe_stacks(
                    StackName="ecommerce-{}-{}".format(self._orig_environment, dependency)
                )
                found = False
                for stack in retval.get("Stacks", []):
                    if stack["StackStatus"] not in [
                        "CREATE_FAILED",
                        "ROLLBACK_IN_PROGRESS", "ROLLBACK_COMPLETE", "ROLLBACK_FAILED",
                        "DELETE_IN_PROGRESS", "DELETE_COMPLETE", "DELETE_FAILED"
                        ]:
                        found = True
                        break
                if found:
                    continue
            except cloudformation.exceptions.ClientError:
                pass
            
            # Check for non-environment-aware stacks
            try:
                retval = cloudformation.describe_stacks(
                    StackName="ecommerce-{}".format(dependency)
                )
                found = False
                for stack in retval.get("Stacks", []):
                    if stack["StackStatus"] not in [
                        "CREATE_FAILED",
                        "ROLLBACK_IN_PROGRESS", "ROLLBACK_COMPLETE", "ROLLBACK_FAILED",
                        "DELETE_IN_PROGRESS", "DELETE_COMPLETE", "DELETE_FAILED"
                        ]:
                        found = True
                        break
                if found:
                    continue
            except cloudformation.exceptions.ClientError:
                pass

            missing_deps.append(dependency)

        if len(missing_deps) > 0:
            self.error("Missing dependencies: {}".format(", ".join(missing_deps)))
            sys.exit(1)

    def cmd_clean(self):
        """
        'clean' command

        Removes the 'build' folder for the service.
        """

        self.info("Cleaning {} build folder".format(self.service))

        try:
            shutil.rmtree(self.build_dir)
        # Ignore if the folder doesn't exist
        except FileNotFoundError:
            pass

    def cmd_deploy(self):
        """
        'deploy' command

        Deploys the service to the developer's AWS account. By default, this
        assumes that this is a development stack.
        """

        if self.environment["environment"]:
            self.info("Deploying {} in {}".format(self.service, self.environment["environment"]))
        else:
            self.info("Deploying {}".format(self.service))

        template_file = os.path.join(self.build_dir, "template.out")
        if self.environment["environment"]:
            stack_name = "ecommerce-{}-{}".format(self.environment["environment"], self.service)
        else:
            stack_name = "ecommerce-{}".format(self.service)

        if not os.path.isdir(self.build_dir) or not os.path.isfile(template_file):
            raise ValueError("'{}' or '{}' not found.".format(self.build_dir, template_file))

        # Display warning for prod environment
        if self.environment.get("flags", {}).get("is-prod", False):
            self.warning("Prod deployment for {}".format(self.service))

        parameters = self._get_parameters(self.environment)
        tags = self._get_tags(self.environment)

        # Deploy stack
        self.run_process(["aws", "cloudformation", "deploy",
            "--stack-name", stack_name,
            "--capabilities", "CAPABILITY_IAM", "CAPABILITY_AUTO_EXPAND",
            # Parameters
            "--parameter-overrides"] + ["{}={}".format(k, v) for k, v in parameters.items()] +
            # Tags
            ["--tags"] + ["{}={}".format(k ,v) for k, v in tags.items()] +
            # Don't fail if there are no changes
            ["--no-fail-on-empty-changeset",
            "--template-file", template_file])

    def cmd_lint(self):
        """
        'lint' command

        Lint various resources in the service. This currently supports:
        
        - CloudFormation templates
        - Lambda function code
        - OpenAPI document
        """

        self.info("Linting {} code".format(self.service))

        # Lint CloudFormation template
        template_file = os.path.join(self.service, "template.yaml")
        if os.path.isfile(template_file):
            template_lint_cmd = [
                "cfn-lint", template_file,
                "--append-rules", os.path.join(self.shared_dir, "lint", "rules"),
                "--ignore-checks", "W2001"
            ]
            # Skip checking parameters if the environment doesn't exist
            if not self.environment["environment"]:
                template_lint_cmd.extend(["--ignore-checks", "E9000"])
            self.run_process(template_lint_cmd)

        # Lint Lambda function code
        if not os.path.isdir(self.source_dir):
            return

        files = []
        for function_name in os.listdir(self.source_dir):
            function_dir = os.path.join(self.source_dir, function_name)
            if not os.path.isdir(function_dir):
                continue

            for filename in os.listdir(function_dir):
                if filename.lower().find(".py") == len(filename)-3:
                    files.append(os.path.join(function_dir, filename))

        process = self.run_process([
            "pylint",
            "--rcfile", os.path.join(self.shared_dir, "lint", "pylintrc")
        ] + files, check=False)
        # Only raise an error for fatal and error messages
        # https://docs.pylint.org/en/1.6.0/run.html#exit-codes
        if process.returncode in [1, 2, 32]:
            process.check_returncode()

        # Lint OpenAPI specifications
        openapi_file = os.path.join(self.resources_dir, "openapi.yaml")
        if os.path.isfile(openapi_file):
            self.run_process([
                "speccy",
                "--config", os.path.join(self.shared_dir, "lint", "speccy.yaml"),
                "lint", openapi_file
            ])

    def cmd_package(self):
        """
        'package' command

        Package the CloudFormation template and stores artifacts into an S3
        bucket provided by the 'S3_BUCKET' environment variable.
        """

        self.info("Packaging {} artifacts".format(self.service))

        s3_bucket = os.environ.get("S3_BUCKET", "{}-src".format(os.environ.get("USER", "")))

        workdir = os.getcwd()
        os.chdir(self.build_dir)
        process = self.run_process(["aws", "cloudformation", "package",
            "--s3-bucket", s3_bucket,
            "--s3-prefix", "artifacts",
            "--template-file", "template.yaml",
            "--output-template-file", "template.out"], check=False)

        os.chdir(workdir)
        # Make sure that we return to the work directory before triggering a failure
        process.check_returncode()

    def cmd_tests_unit(self):
        """
        'tests-unit' command

        Run unit tests for Lambda functions defined in the service.
        """

        if self.metadata.get("flags", {}).get("skip-tests", False):
            self.warning("Skipping {} unit tests".format(self.service))
            return

        self.info("Running {} unit tests".format(self.service))

        tests_dir = os.path.join(self.tests_dir, "unit")

        # If there are no tests, abort
        if not os.path.isdir(tests_dir):
            raise ValueError("'{}' does not exist".format(tests_dir))

        # Set environment variables
        os.environ["ECOM_BUILD_DIR"] = self.build_dir

        # Inject shared modules for unit tests in the PYTHONPATH
        shared_tests = os.path.join(self.shared_dir, "tests", "unit")
        if os.environ.get("PYTHONPATH", "") != "":
            os.environ["PYTHONPATH"] = "{}:{}".format(shared_tests, os.environ["PYTHONPATH"])
        else:
            os.environ["PYTHONPATH"] = shared_tests

        # Inject environment variables for boto3
        environ_keys = ["AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY", "AWS_DEFAULT_REGION"]
        orig_environ = {}
        for key in environ_keys:
            if key in os.environ:
                orig_environ[key] = os.environ[key]

        os.environ["AWS_ACCESS_KEY_ID"] = "AWS_ACCESS_KEY_ID"
        os.environ["AWS_SECRET_ACCESS_KEY"] = "AWS_SECRET_ACCESS_KEY"
        os.environ["AWS_DEFAULT_REGION"] = "eu-west-1"

        self.run_process(["pytest", tests_dir,
            "--cov", self.build_dir,
            "--cov-config", os.path.join(shared_tests, "coveragerc")])

        # Restore environment variables
        for key in environ_keys:
            if key in orig_environ:
                os.environ[key] = orig_environ[key]
            else:
                del os.environ[key]

    def cmd_display_metadata(self):
        """
        'display-metadata' command

        Display metadata about the service
        """

        self.info("Displaying {} metadata".format(self.service))
        print(yaml.dump(self.metadata), end="")

    def cmd_display_parameters(self):
        """
        'display-parameters' command

        Display parameters for the given environment
        """

        self.info("Displaying {} parameters".format(self.service))
        print(yaml.dump(self._get_parameters(self.environment)), end="")

    def cmd_display_tags(self):
        """
        'display-tags' command

        Display tags for the given environment
        """

        self.info("Displaying {} tags".format(self.service))
        print(yaml.dump(self._get_tags(self.environment)), end="")

    def cmd_tests_integ(self):
        """
        'tests-integ' command

        Run integration tests for a service.
        """

        if self.metadata.get("flags", {}).get("skip-tests", False):
            self.warning("Skipping {} integration tests".format(self.service))
            return

        self.info("Running {} integration tests".format(self.service))

        tests_dir = os.path.join(self.tests_dir, "integ")
        if not os.path.isdir(tests_dir):
            raise ValueError("'{}' does not exist".format(tests_dir))

        if not self.environment.get("flags", {}).get("can-test", True):
            raise ValueError("Cannot run tests in {environment}".format(**self.environment))

        # Inject shared modules for unit tests in the PYTHONPATH
        shared_tests = os.path.join(self.shared_dir, "tests", "integ")
        if os.environ.get("PYTHONPATH", "") != "":
            os.environ["PYTHONPATH"] = "{}:{}".format(shared_tests, os.environ["PYTHONPATH"])
        else:
            os.environ["PYTHONPATH"] = shared_tests

        # Set the environment name
        os.environ["ECOM_ENVIRONMENT"] = self.environment["environment"]

        self.run_process(["pytest", tests_dir])

    ################
    # TEXT METHODS #
    ################

    def text_red(self, text: str) -> str:
        """
        Return the text in red if this is an interactive session
        """
        if self.color == "yes" or (self.is_interactive and self.color == "auto"):
            return "\033[91m{}\033[0m".format(text)
        return text

    def text_green(self, text: str) -> str:
        """
        Return the text in green if this is an interactive session
        """
        if self.color == "yes" or (self.is_interactive and self.color == "auto"):
            return "\033[92m{}\033[0m".format(text)
        return text

    def text_yellow(self, text: str) -> str:
        """
        Return the text in green if this is an interactive session
        """
        if self.color == "yes" or (self.is_interactive and self.color == "auto"):
            return "\033[93m{}\033[0m".format(text)
        return text

    def text_blue(self, text: str) -> str:
        """
        Return the text in blue if this is an interactive session
        """
        if self.color == "yes" or (self.is_interactive and self.color == "auto"):
            return "\033[94m{}\033[0m".format(text)
        return text

    def info(self, text: str) -> None:
        """
        Print an information message
        """

        print("[*] {}: {}".format(self.service, self.text_blue(text)))

    def warning(self, text: str) -> None:
        """
        Print a warning message
        """

        print("[!] {}: {}".format(self.service, self.text_yellow(text)))

    def error(self, text: str) -> None:
        """
        Print an error message
        """

        print("[!] {}: {}".format(self.service, self.text_red(text)))

    ######################
    # RUN PROCESS METHOD #
    ######################

    def run_process(self, cmds: List[str], check: bool=True):
        """
        Run a subprocess
        """

        if self.quiet:
            process = subprocess.run(cmds, text=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        else:
            process = subprocess.run(cmds)

        if check:
            try:
                process.check_returncode()
            except Exception as exc:
                if self.quiet:
                    print(process.stdout)
                raise exc
        return process

    ##################
    # HELPER METHODS #
    ##################

    def _build_artifacts(self):
        """
        Build all artifacts for the service for integration with CodePipeline

        See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-cfn-artifacts.html
        """

        # Create the 'artifacts' folder
        try:
            os.mkdir(self.artifacts_build_dir)
        except FileExistsError:
            pass

        for environment in self._get_all_environments().values():
            config = {
                "Parameters": self._get_parameters(environment),
                "Tags": self._get_tags(environment)
            }
            artifact_file = os.path.join(self.artifacts_build_dir, "config.{environment}.json".format(**environment))
            with open(artifact_file, "w") as fp:
                json.dump(config, fp, indent=2)

    def _copy_openapi(self):
        """
        Parse OpenAPI specs and returns a merged document
        """

        openapi_file = os.path.join(self.resources_dir, "openapi.yaml")
        openapi_out_file = os.path.join(self.resources_build_dir, "openapi.yaml")

        # Skip if there are no OpenAPI specifications for that service
        if not os.path.isfile(openapi_file):
            return

        self.run_process(["speccy", "resolve", openapi_file, "-o", openapi_out_file])

    def _get_all_environments(self):
        """
        Retrieve all environments
        """

        # Load and validate environments.yaml
        schema_file = os.path.join(self.shared_dir, "environments", "schema.yaml")
        environments_file = "environments.yaml"

        if not os.path.isfile(environments_file):
            raise ValueError("Missing environments file '{}'".format(environments_file))

        with open(schema_file) as fp:
            schema = yaml.load(fp, Loader=yaml.SafeLoader)

        with open(environments_file) as fp:
            environments = yaml.load(fp, Loader=yaml.SafeLoader)

        jsonschema.validate(environments, schema)

        # For services that don't support environments, default to prod
        if not self.metadata.get("flags", {}).get("environment", True):
            environment = environments.get("prod", {})
            environment["environment"] = ""
            return {"": environment}

        # Inject the 'environment' key
        for key, environment in environments.items():
            environment["environment"] = key

        # Return all environments
        return environments

    def _get_all_services(self):
        """
        Retrieve all services in the project
        """

        return {
            name for name in os.listdir(os.getcwd())
            if os.path.isfile(os.path.join(os.getcwd(), name, "metadata.yaml"))
        }

    def _get_environment(self, environment_name):
        """
        Retrieve the environment
        """

        # Load and validate environments.yaml
        schema_file = os.path.join(self.shared_dir, "environments", "schema.yaml")
        environments_file = "environments.yaml"

        if not os.path.isfile(environments_file):
            raise ValueError("Missing environments file '{}'".format(environments_file))

        with open(schema_file) as fp:
            schema = yaml.load(fp, Loader=yaml.SafeLoader)

        with open(environments_file) as fp:
            environments = yaml.load(fp, Loader=yaml.SafeLoader)

        jsonschema.validate(environments, schema)

        # For services that don't support environments, default to prod
        if not self.metadata.get("flags", {}).get("environment", True):
            environment = environments.get("prod", {})
            environment["environment"] = ""
            return environment

        if environment_name not in environments:
            raise ValueError("Missing environment '{}'".format(environment))

        environment = environments[environment_name]
        environment["environment"] = environment_name
        return environment

    def _get_metadata(self):
        """
        Load metadata for the service
        """

        schema_file = os.path.join(self.shared_dir, "metadata", "schema.yaml")
        metadata_file = os.path.join(self.service, "metadata.yaml")

        if not os.path.isfile(metadata_file):
            raise ValueError("Missing metadata file '{}'".format(metadata_file))

        with open(schema_file) as fp:
            schema = yaml.load(fp, Loader=yaml.SafeLoader)

        with open(metadata_file) as fp:
            metadata = yaml.load(fp, Loader=yaml.SafeLoader)

        jsonschema.validate(metadata, schema)

        return metadata

    def _get_parameters(self, environment):
        """
        Returns CloudFormation parameters based on the environment and metadata
        """
    
        # Set Environment
        base_params = {
            # If environment is an empty string, returns prod
            "Environment": environment["environment"] or "prod"
        }
        # Load from environments.yaml
        for key, value in environment.get("parameters", {}).items():
            if isinstance(value, str):
                base_params[key] = value.format(**base_params)
            else:
                base_params[key] = value

        # Load from metadata.yaml
        parameters = copy.deepcopy(base_params)
        for key, value in self.metadata.get("parameters", {}).items():
            if isinstance(value, str):
                parameters[key] = value.format(**base_params)
            else:
                parameters[key] = value

        return parameters

    def _get_tags(self, environment):
        """
        Returns tags for the Template Configuration file based on the environment
        """

        # Set Environment
        base_tags = {
            # Inject the service name
            "Service": self.service,
            # If "environment" is an empty string, returns "prod"
            "Environment": environment["environment"] or "prod"
        }
        # Load from environments.yaml
        for key, value in environment.get("tags", {}).items():
            if isinstance(value, str):
                base_tags[key] = value.format(**base_tags)
            else:
                base_tags[key] = value

        # Load from metadata.yaml
        tags = copy.deepcopy(base_tags)
        for key, value in self.metadata.get("tags", {}).items():
            if isinstance(value, str):
                tags[key] = value.format(**base_tags)
            else:
                tags[key] = value

        return tags

    def _install_packages(self):
        """
        Install packages for Lambda functions in the service
        """
        if not os.path.isdir(self.source_build_dir):
            return

        # Loop through directories in the 'src' folder
        for name in os.listdir(self.source_build_dir):
            path = os.path.join(self.source_build_dir, name)

            # If there is a requirements.txt file, we need to install extra packages.
            if os.path.isfile(os.path.join(path, "requirements.txt")):
                self.run_process(["/usr/bin/env", "python3", "-m", "pip", "install",
                    "--requirement", os.path.join(path, "requirements.txt"),
                    "--target", path])


if __name__ == "__main__":
    args = get_args()

    toolbox = ToolBox(args.service, vars(args))
    toolbox.run(args.commands)