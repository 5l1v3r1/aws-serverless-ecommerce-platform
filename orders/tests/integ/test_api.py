import datetime
import os
import random
import string
import uuid
import boto3
import pytest
import requests
from urllib.parse import urlparse
from aws_requests_auth.boto_utils import BotoAWSRequestsAuth
from helpers import compare_dict # pylint: disable=no-name-in-module


ssm = boto3.client("ssm")


ECOM_ENVIRONMENT = os.environ["ECOM_ENVIRONMENT"]
TABLE_NAME = ssm.get_parameter(
    Name="/ecommerce/{}/orders/table/name".format(ECOM_ENVIRONMENT)
)["Parameter"]["Value"]
ENDPOINT_URL = ssm.get_parameter(
    Name="/ecommerce/{}/orders/api/url".format(ECOM_ENVIRONMENT)
)["Parameter"]["Value"]
USER_POOL_ID = ssm.get_parameter(
    Name="/ecommerce/{}/users/user-pool/id".format(ECOM_ENVIRONMENT)
)["Parameter"]["Value"]


cognito = boto3.client("cognito-idp")
table = boto3.resource("dynamodb").Table(TABLE_NAME) # pylint: disable=no-member


@pytest.fixture(scope="module")
def password():
    """
    Generate a unique password for the user
    """

    return "".join(
        random.choices(string.ascii_uppercase, k=10) +
        random.choices(string.ascii_lowercase, k=10) +
        random.choices(string.digits, k=5) +
        random.choices(string.punctuation, k=3)
    )


@pytest.fixture(scope="module")
def email():
    """
    Generate a unique email address for the user
    """

    return "".join(random.choices(string.ascii_lowercase, k=20))+"@example.local"


@pytest.fixture(scope="module")
def client_id():
    """
    Return a user pool client
    """

    # Create a Cognito User Pool Client
    response = cognito.create_user_pool_client(
        UserPoolId=USER_POOL_ID,
        ClientName="ORDERS_TEST_CLIENT",
        GenerateSecret=False,
        ExplicitAuthFlows=["ADMIN_NO_SRP_AUTH"]
    )

    # Return the client ID
    client_id = response["UserPoolClient"]["ClientId"]
    yield client_id

    # Delete the client
    cognito.delete_user_pool_client(
        UserPoolId=USER_POOL_ID,
        ClientId=client_id
    )


@pytest.fixture(scope="module")
def user_id(email, password):
    """
    User ID generated by Cognito
    """

    # Create a Cognito user
    response = cognito.admin_create_user(
        UserPoolId=USER_POOL_ID,
        Username=email,
        UserAttributes=[{
            "Name": "email",
            "Value": email
        }]
    )
    user_id = response["User"]["Username"]
    cognito.admin_set_user_password(
        UserPoolId=USER_POOL_ID,
        Username=user_id,
        Password=password,
        Permanent=True
    )

    # Return the user ID
    yield user_id

    # Delete the user
    cognito.admin_delete_user(
        UserPoolId=USER_POOL_ID,
        Username=user_id
    )


@pytest.fixture(scope="module")
def jwt_token(user_id, client_id, email, password):
    """
    Returns a JWT token for API Gateway
    """

    response = cognito.admin_initiate_auth(
        UserPoolId=USER_POOL_ID,
        ClientId=client_id,
        AuthFlow="ADMIN_NO_SRP_AUTH",
        AuthParameters={
            "USERNAME": email,
            "PASSWORD": password
        }
    )

    return response["AuthenticationResult"]["IdToken"]


@pytest.fixture(scope="module")
def order(user_id):
    """
    Order as stored in DynamoDB
    """

    now = datetime.datetime.now()

    order = {
        "orderId": str(uuid.uuid4()),
        "userId": user_id,
        "createdDate": now.isoformat(),
        "modifiedDate": now.isoformat(),
        "status": "NEW",
        "products": [{
            "productId": str(uuid.uuid4()),
            "name": "Test Product",
            "package": {
                "width": 1000,
                "length": 900,
                "height": 800,
                "weight": 700
            },
            "price": 300,
            "quantity": 4
        }],
        "address": {
            "name": "John Doe",
            "companyName": "Company Inc.",
            "streetAddress": "123 Street St",
            "postCode": "12345",
            "city": "Town",
            "state": "State",
            "country": "SE",
            "phoneNumber": "+123456789"
        },
        "deliveryPrice": 200,
        "total": 1400
    }

    table.put_item(Item=order)

    yield order

    table.delete_item(
        Key={"orderId": order["orderId"]}
    )


@pytest.fixture
def iam_auth():
    """
    Helper function to return auth for IAM
    """

    url = urlparse(ENDPOINT_URL)
    region = boto3.session.Session().region_name

    return BotoAWSRequestsAuth(aws_host=url.netloc,
                               aws_region=region,
                               aws_service='execute-api')


def test_get_root(jwt_token, order):
    """
    Test GET /
    """

    res = requests.get(ENDPOINT_URL+"/", headers={"Authorization": jwt_token})
    assert res.status_code == 200
    body = res.json()
    assert "orders" in body
    assert len(body["orders"]) == 1
    compare_dict(order, body["orders"][0])


def test_get_root_no_auth(order):
    """
    Test GET / without auth
    """

    res = requests.get(ENDPOINT_URL+"/")
    assert res.status_code == 401
    body = res.json()
    assert "message" in body
    assert isinstance(body["message"], str)


def test_get_order(jwt_token, order):
    """
    Test GET /{orderId}
    """

    res = requests.get(ENDPOINT_URL+"/"+order["orderId"], headers={"Authorization": jwt_token})
    assert res.status_code == 200
    body = res.json()
    compare_dict(order, body)


def test_get_order_no_auth(order):
    """
    Test GET /{orderId} without auth token
    """

    res = requests.get(ENDPOINT_URL+"/"+order["orderId"])
    assert res.status_code == 401
    body = res.json()
    assert "message" in body
    assert isinstance(body["message"], str)


def test_get_order_wrong_id(jwt_token, order):
    """
    Test GET /{orderId} with a non-existent orderId
    """

    res = requests.get(ENDPOINT_URL+"/"+order["orderId"]+"a", headers={"Authorization": jwt_token})
    assert res.status_code == 404
    body = res.json()
    assert "message" in body
    assert isinstance(body["message"], str)


def test_get_backend_order(iam_auth, order):
    """
    Test GET /backend/{orderId}
    """

    res = requests.get(ENDPOINT_URL+"/backend/"+order["orderId"], auth=iam_auth)
    assert res.status_code == 200
    body = res.json()
    compare_dict(order, body)


def test_get_backend_order_no_auth(iam_auth, order):
    """
    Test GET /backend/{orderId} without auth
    """

    res = requests.get(ENDPOINT_URL+"/backend/"+order["orderId"])
    assert res.status_code == 403
    body = res.json()
    assert "message" in body
    assert isinstance(body["message"], str)


def test_get_backend_order_wrong_id(iam_auth, order):
    """
    Test GET /backend/{orderId} with a non-existent orderId
    """

    res = requests.get(ENDPOINT_URL+"/backend/"+order["orderId"]+"a", auth=iam_auth)
    assert res.status_code == 404
    body = res.json()
    assert "message" in body
    assert isinstance(body["message"], str)